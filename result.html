Данная система разрабатывается для непрерывной обработки больших объемов данных, для организации взаимодействия между веб-сервисами и интеграцией с различными источниками данных, поэтому все ее компоненты должны быть грамотно спроектированы и реализованы. Наша система включает следующие компоненты:
<ol><li>REST-сервисы;</li>
<li>нереляционная база данных;</li><li>
хранилище больших данных;</li><li>
шаблонизаторы;</li><li>
реализации различных протоколов взаимодействия;</li><li>
программные продукты, работающие на кластерах из большого количества машин.</li><ol>
	Требование, которое должна соблюдать система – качественная обработка данных, обработка ошибок, возможность перезапуска обработки поврежденных или ошибочных данных, работа «24 на 7».
		<br>Основным функциональным требованием к разрабатываемой системе является корректная работа в течение периода обработки данных. Обработка данных должна быть точной, корректной, т.к. данные являются основой деятельности других систем. Данные должны иметь возможность репликации.
Что касается надежности данного программного продукта, то оно должно быть выполнено качественно, не должно иметь слабых мест, не должно вылетать при запуске и работе, должно работать как можно быстрее, в нем должны быть обработаны все исключительные ситуации и по возможности учтены все нюансы тех продуктов, которые уже существуют на рынке, чтобы при выходе на рынок быть конкурентно способным. Очень важно создать необходимые условия для того, чтобы при отказе одного из компонентов, состояние, на котором остановилась система, можно было сохранить и при исправлении сломанного компонента, обработка данных могла быть продолжена, либо могли иметь возможность подключиться к резервным компонентам.
Разработанный программный продукт предназначен для использования в формате «24 на 7». Он расширяем, гибок к изменению и введению новшеств. Предназначен для долговременного запуска и обработки данных, получая из одного хранилища данных и складывая в другое, проделав некоторые преобразования.
Система состоит из множества различных компонентов, которые дублируются на различных узлах системы. Для нормального функционирования системы используется несколько кластеров машин. В качестве операционных систем могут быть использованы серверные Windows и Unix системы (также могут быть использованы аналоги операционных систем, не относящиеся к классу серверных). Минимальные конфигурации машин на узлах кластеров зависят от того, какие компоненты на них работают. Так как большинство компонент написаны с использованием языка программирования Java, то сложность переносимости компонент на различные узлы системы сводится к минимуму.
Компоненты системы могут работать на различных типах операционных систем, так как большинство из них написано с использованием Java. <br>
При разработке приложения используются следующие компоненты:
<ol><li>языки программирования – Java, Scala;</li><li>
язык разметки XML, JSON.</li><ol>
          В качестве промежуточного программного обеспечения или шины сообщений я выбрал реализацию Akka и систему акторов от компании Typesafe. Данный фреймворк написан на языке Scala и предоставляет огромный функционал для организации реактивного программирования на базе передачи сообщений. Также этот фреймворк отлично подошел организации кластерного взаимодействия. На данный момент этот проект развивается очень быстро. 
          Для реализации веб-сервера я использовал Netty фреймворк. Он является легковесным, конфигурируемым, с хорошей производительностью (благодаря неблокирующим операциям взаимодействия с клиентами) [19]. 
          В качестве инструмента гарантированной доставки я использую работу с LevelDB (разработана компанией Google). Это легковесное «key-value» («ключ-значение») хранилище данных, с быстрыми операциями вставки и получения элементов. В данном проекте вставка значений реализована в асинхронной манере.<br>
Рассмотрим все варианты использования системы, которые пользователь может применить к ней:
1) создание веб-приложения: разработчик может создавать веб приложение на основе разрабатываемого в этом дипломном проекте встраиваемого веб-сервера;
<br>2) создание веб-интерфейса для существующего приложения: разработчик может создавать веб-интерфейс на основе разрабатываемого в этом дипломном проекте встраиваемого веб-сервера, при этом, существующее приложение не обязательно должно быть веб-приложением;
<br>3) создание REST сервиса: функционал и набор интерфейсов встраиваемого веб-сервера позволяет в кратчайшие сроки создавать различные REST сервисы;
<br>4) реализация логики по авторизации пользователей: разработчик может реализовать свою собственную логику авторизации пользователей в веб-приложении;
<br>5) разработчик имеет возможность использовать шаблонизатор либо подключить реализацию стороннего;
<br>6) разработчик имеет возможность использовать ajax в своем приложении;
<br>7) использование HTTPS протокола: разработчик может использовать этот протокол для своего приложения вместо стандартного HTTP;
<br>8) разработчик имеет возможность гибко конфигурировать свое приложение: эта возможность доступна как при помощи внешнего файла с определенным синтаксисом, так и при помощи Java;
<br>9) использование groovy или scala в качестве основных языков разработки для веб-приложения;
<br>10) возможность сохранения сообщений: система может быть настроена таким образом, чтобы иметь возможность сохранять сообщения, которые еще не были доставлены по какой-либо причине (отказ сервера, исключительная ситуация, отказ других компонент системы);
<br>11) добавление мониторинга: разработчик имеет возможность легко организовывать мониторинг работы системы; сюда можно включить логирование и сбор статистики;
<br>12) создание кластера: разработчик имеет возможность объединения веб-приложений в кластеры, а также организацию обмена данными между различными кластерами;
<br>13) разработчик имеет возможность конфигурировать так называемый троттлинг, то есть ограничение пропускной способности веб-приложений;
<br>14) система поддерживает возможность легкой интеграции с любыми компонентами Apache Camel.
<br>
Разработанный продукт предоставляет средства для интеграции уже имеющихся сервисов, а также для создания самих веб-сервисов. Для того, чтобы создать веб-приложение на основе созданного продукта, необходимо выполнить несколько простых действий. Сперва создадим стандартный проект для Java (Scala), потом добавим в зависимости проекта jar-файл с реализацией продукта и интерфейсами для взаимодействия с ним. После этого можно приступать к созданию самого веб-приложения. Для начала, создадим файл конфигурации: 

<code data-gist-id="48beed1d9e477c94d7360fdb2342e125"></code>

В этом файле мы указали папку для загрузки шаблонов, т.е. папку, в которой у нас будут лежать все странички и ресурсы (свойство app.template.directory). Также мы указали порт и хост, на котором будет доступен наш сервер (свойства app.netty.port и app.netty.host). Далее идет конфигурация роутера в следующем виде: имя метода, пробельный символ, путь, по которому будет доступен ресурс и конфигурация контроллера, которая включает в себя имя класса контроллера, его имя (необязательное свойство) и количество экземпляров контроллеров, что позволяет уменьшить время отклика сервера. Для динамических путей в URL можно добавить символ «:». Свойства, перечисленные внизу файла, предназначены для конфигурации персистенции сообщений в LevelDB.
Далее необходимо создать класс приложения. Класс приложения должен наследоваться от класса WebApplicationAdapter:

 
<code data-gist-id="33eb17461c47b1617f7629503a01f6eb"></code>

Если файл конфигурации лежит в папке resources (или указан в Classpath), то можно не указывать имя файла конфигурации.
Следующий шаг – создание класса контроллера. Здесь представлен простой Rest-контроллер, который отравляет ответ в формате JSON пользователю:

 <code data-gist-id="2a8351bc3d17dad45f8a7e873233735f"></code>

Такой контроллер наследуется от класса ControllerActor. В методе index получаем параметр из динамического пути, устанавливаем ее в Map для объектов, которые будут доступны из шаблона нашей индексной страницы. В методе пост создается тестовый объект, в который мы задаем сообщение и цифру. Далее этот объект преобразовываем в JSON и отправляем клиенту.
Создадим html-страницу. Добавим скрипт для ajax запроса. Скрипт посылает post-запрос на сервер с данными, взятыми из текстового поля. После успешного получения результата запроса, данные ответа отображаются на странице чуть ниже текстового поля. В случае ошибки, поле, куда должен будет отобразиться результат, будет пустым. Ошибка будет залогирована на сервере, либо в консоли браузера.

 
 <code data-gist-id="64e8cd4d678954801dfaed31b5d5bacc"></code>

Есть возможность создавать интеграционные решения на основе специального класса контроллеров. Пример:

 <code data-gist-id="a595994bfb1b65c4fbf29e28e8b28a64"></code>
 
Этот контроллер наследуется от класса CamelControllerActor. Работа этой реализации следующая: пользователь делает post-запрос по адресу http://localhost:8080/hello, после чего получает ответ в виде содержимого, находящегося в файле transactions.csv.
Веб-приложения, созданные на основе разработанного продукта, имеют возможность организации в кластеры и меж кластерного взаимодействия. Пример конфигурации представлен на рисунке 3.12.
Последние три свойства предназначены для конфигурации мониторинга сервисов и кластеров, имеется возможность сбора метрик по кластерам с помощью Sigar библиотеки.
Свойство log-remote-lifecycle-events задает включение и отключение отображения логов событий жизненного цикла кластера. К событиям жизненного цикла кластера относятся такие события, как: подключение нового узла, уход узла, передача данных между узлами, исключительные ситуации при работе кластера, перенос полномочий главного узла на другой существующий узел и т.д. Свойство seed-nodes задает список адресов заранее известных узлов.
 
<code data-gist-id="72832dc965897acd863ec340e435aa31"></code>

Также было проведено нагрузочное тестирование. Были созданы 50 клиентов, которые делали параллельно get и post запросы к тестовому приложению.
<br>
В процессе написания веб-сервера для тестирования некоторых ключевых моментов были написаны юнит-тесты. Результаты тестирования показали, что все поставленные задачи были выполнены корректно, а цель реализована. Также следует выделить планы развития разрабатываемого продукта на будущее, которые позволят улучшить данный программный продукт.
  К ним я отнес следующие пункты:
<ol><li>1) интеграция с Finagle (Twitter) – протокол-агностические средства для создания микро-сервисной архитектуры;</li><li>
2) интеграция с Kamon – продвинутыми инструментами мониторинга приложений на базе JVM;</li><li>
3) поддержка других хранилищ данных для персистенции и мониторинга и логирования сообщений (сейчас имеется поддержка LevelDB);</li><li>
4) добавление поддержки нативных пулов потоков для повышения производительности;</li><li>
5) реализация более гибкой конфигурации;</li><li>
6) реализация улучшенного перехвата исключительных ситуаций на уровне кластера;</li><li>
7) создание утилит для тестирования приложений на базе разрабатываемого продукта.</li><ol>
